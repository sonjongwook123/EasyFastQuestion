{
    "entries": [
        {
            "question": "유니티 오브젝트가 앞으로 이동하는 기본적인 코드",
            "questionDateString": "2025-07-18T17:13:35.4881698+09:00",
            "answers": [
                {
                    "answerText": "API 호출 중 예외 발생: UnityWebRequest failed: HTTP/1.1 404 Not Found\nResponse: {\n  \"error\": {\n    \"code\": 404,\n    \"message\": \"models/gemini-pro is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\",\n    \"status\": \"NOT_FOUND\"\n  }\n}\n",
                    "codes": [],
                    "answerDateString": "2025-07-18T17:13:37.5984748+09:00"
                }
            ],
            "isImportant": false,
            "source": "Gemini"
        },
        {
            "question": "유니티 오브젝트가 앞으로 이동하는 기본적인 코드",
            "questionDateString": "2025-07-18T17:16:55.0385620+09:00",
            "answers": [
                {
                    "answerText": "API 호출 중 예외 발생: UnityWebRequest failed: HTTP/1.1 404 Not Found\nResponse: {\n  \"error\": {\n    \"code\": 404,\n    \"message\": \"models/gemini-pro is not found for API version v1beta, or is not supported for generateContent. Call ListModels to see the list of available models and their supported methods.\",\n    \"status\": \"NOT_FOUND\"\n  }\n}\n",
                    "codes": [],
                    "answerDateString": "2025-07-18T17:16:56.5318289+09:00"
                }
            ],
            "isImportant": false,
            "source": "Gemini"
        },
        {
            "question": "유니티 오브젝트가 앞으로 이동하는 기본적인 코드",
            "questionDateString": "2025-07-18T17:19:52.0692561+09:00",
            "answers": [
                {
                    "answerText": "유니티 오브젝트를 앞으로 이동하는 방법은 여러 가지가 있습니다.  어떤 방법이 가장 적절한지는 프로젝트의 구조와 원하는 이동 방식에 따라 다릅니다.  몇 가지 예시를 보여드리겠습니다.\n\n**방법 1: `Transform.Translate` 사용 (매 프레임 이동)**\n\n가장 간단하고 직관적인 방법입니다.  매 프레임마다 오브젝트의 위치를 조금씩 변경합니다.  `Time.deltaTime`을 사용하여 프레임 레이트에 독립적인 이동을 구현합니다.\n\n```csharp\nusing UnityEngine;\n\npublic class MoveForward : MonoBehaviour\n{\n    public float speed = 5f; // 이동 속도\n\n    void Update()\n    {\n        transform.Translate(Vector3.forward * speed * Time.deltaTime);\n    }\n}\n```\n\n* `speed`:  초당 이동 거리를 정의합니다.\n* `Time.deltaTime`:  두 프레임 사이의 시간 간격입니다. 이를 곱함으로써 프레임 레이트에 상관없이 일정한 속도를 유지합니다.\n* `Vector3.forward`: 오브젝트의 Z축 방향을 나타냅니다.  오브젝트의 로컬 좌표계를 기준으로 이동합니다.  월드 좌표계를 기준으로 이동하려면 `transform.Translate(Vector3.forward * speed * Time.deltaTime, Space.World);` 와 같이 `Space.World`를 추가합니다.\n\n\n**방법 2: `Rigidbody.velocity` 사용 (물리 엔진 사용)**\n\n물리 엔진을 사용하여 오브젝트를 이동시킵니다.  충돌이나 중력과 같은 물리적 효과를 고려해야 할 때 유용합니다.\n\n```csharp\nusing UnityEngine;\n\npublic class MoveForwardRigidbody : MonoBehaviour\n{\n    public float speed = 5f; // 이동 속도\n    private Rigidbody rb;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody>();\n        if (rb == null)\n        {\n            Debug.LogError(\"Rigidbody component not found!\");\n        }\n    }\n\n    void FixedUpdate()\n    {\n        rb.velocity = transform.forward * speed;\n    }\n}\n```\n\n* `FixedUpdate()` 함수는 물리 연산을 위해 사용됩니다.  `Update()` 대신 사용해야 합니다.\n* `Rigidbody` 컴포넌트가 필요합니다.  오브젝트에 `Rigidbody` 컴포넌트를 추가해야 합니다.\n\n\n**방법 3: `CharacterController` 사용 (캐릭터 이동)**\n\n캐릭터를 제어하는 데 특화된 컴포넌트입니다.  충돌 처리가 효율적이며, 흔히 캐릭터 이동에 사용됩니다.\n\n```csharp\nusing UnityEngine;\n\npublic class MoveForwardCharacterController : MonoBehaviour\n{\n    public float speed = 5f; // 이동 속도\n    private CharacterController controller;\n\n    void Start()\n    {\n        controller = GetComponent<CharacterController>();\n        if (controller == null)\n        {\n            Debug.LogError(\"CharacterController component not found!\");\n        }\n    }\n\n    void Update()\n    {\n        Vector3 moveDirection = transform.forward * speed;\n        controller.Move(moveDirection * Time.deltaTime);\n    }\n}\n```\n\n* `CharacterController` 컴포넌트가 필요합니다. 오브젝트에 `CharacterController` 컴포넌트를 추가해야 합니다.\n\n\n위의 코드들은 모두 오브젝트를 Z축 방향(앞으로)으로 이동시킵니다.  X축 또는 Y축 방향으로 이동하려면 `Vector3.forward`를 `Vector3.right` 또는 `Vector3.up`으로 바꾸면 됩니다.  원하는 방향 벡터를 직접 지정할 수도 있습니다 (예: `new Vector3(1, 0, 0)`).  어떤 방법을 선택할지는 여러분의 게임 디자인과 요구사항에 따라 달라집니다.  각 방법의 장단점을 고려하여 적절한 방법을 선택하세요.\n",
                    "codes": [],
                    "answerDateString": "2025-07-18T17:20:00.4318899+09:00"
                },
                {
                    "answerText": "qwwqf",
                    "codes": [],
                    "answerDateString": "2025-07-18T17:23:42.5647495+09:00"
                },
                {
                    "answerText": "sadasa",
                    "codes": [],
                    "answerDateString": "2025-07-18T17:42:10.7106992+09:00"
                },
                {
                    "answerText": "sada",
                    "codes": [
                        {
                            "name": "adad.cs",
                            "content": "asad",
                            "saveDateString": "2025-07-18T17:42:15.3788123+09:00"
                        }
                    ],
                    "answerDateString": "2025-07-18T17:42:15.3788123+09:00"
                }
            ],
            "isImportant": false,
            "source": "Gemini"
        }
    ]
}